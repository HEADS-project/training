### How to use generated public APIs to integrate with ThingML at the code level (in Java)?

Imagine you have this configuration:

```
configuration Deployment0 {
    instance timer : TimerJava
}
```

Now if you generate the Java code and run the main, it won't do much: no one is calling the `timer_start` and no one is listening for the `timer_timeout` message.

We have seen in Tutorial 1 how Java (or JS, or C) code can be mixed with ThingML models. We will now see how we can integrate legacy/third-party code with ThingML,
directly at the code level using the public APIs generated by ThingML.

The generated code has the following structure:

```
src/main/java
|--api                        #this package defines the public interfaces
   |--ITimerJava_timer        #the interface the generated timer implements, allowing you to call start/stop methods
      ITimerJava_timerClient  #the callback interface one should implements to listen to the timer i.e. receive the timeout
|--messages
|--Main                       #the code corresponding to the configuration, where things and connector are instantiated
   TimerJava                  #the code generated for the TimerJava thing
```

Looking in more details at `Main.java`:

```java
public class Main {
    //Things
    public static TimerJava TimerJava_Deployment0_timer;

    public static void main(String args[]) {
        //Things
        TimerJava_Deployment0_timer = (TimerJava) new TimerJava("Deployment0_timer: TimerJava", (Thread) null).buildBehavior();

        //Connectors (none defined in the configuration)

        //Starting Things
        TimerJava_Deployment0_timer.start();

        //Hook to catch the SIG-INT signal and properly terminate the ThingML App
        Runtime.getRuntime().addShutdownHook(new Thread() {
            public void run() {
                System.out.println("Terminating ThingML app...");
                TimerJava_Deployment0_timer.stop();
                System.out.println("ThingML app terminated. RIP!");
            }
        });
    }
}
```

It is composed of four main sections:

- instantiation of things
- instantiation of connectors that connects ports defined on the thing instances
- startup of things
- shutdown of things on `SIG-INT`

Again, this main is pretty useless as it only instantiate a timer that no one uses.

However, you can register a listener on the timer (after it has been instantiated, and ideally before it has beem started)
so that you can get notified when the timer emits a timeout:

```java
TimerJava_Deployment0_timer.registerOnTimer(new ITimerJava_timerClient() {
            @Override
            public void timer_timeout_from_timer() {
                System.out.println("TIMEOUT!!!!!!!!!!");
            }
        });
```

> Note that we directly instantiate the interface defined in the API package and provide its implementation (anonymous classe).
You can of course define your own class that implements this interface.

Well... listening to the timeout will not really help, until you call the timer_start (after the thing instance has been started):

```java
TimerJava_Deployment0_timer.timer_start_via_timer((short) 2000);
```

After two seconds, you should see a `TIMEOUT!!!!!!!!!!` in the console.


> The ThingML to Kevoree/Java transformation basically use the same mechanisms to wrap the generated code into
Kevoree components


### How to generate Kevoree/Java components from a ThingML configuration?

Short answer:
- generate the plain Java code as usual, and then
- generate the Kevoree code using the `ThingML -> Compile Java Kevoree` button in the HEADS IDE.

> You should compile the plain Java code first. The Kevoree transformation will simply add a few classes (that use the
core classes) and update the pom.xml with the required dependencies.

Long answer: **better read the following sub-sections first** to understand the different mappings between ThingML
configuration and Kevoree deployment models!

#### All components are defined and connected in the ThingML configuration

If all your components are defined in a single ThingML configuration, and if all the ports are connected, it will generate a single Kevoree component with no exposed port. Everything will be internally managed by ThingML and seen as a black box by Kevoree. 

> In general, it might not be a good idea to bind instantiate and connect everything in your ThingML configuration, as it reduces the flexibility you will have at runtime to manage your application. However, in more complex configurations (involving more than two components), it is a good idea to hide some *things*, which you just consider as implementation details.

#### All components are defined, but only partially (or not at all) connected in the ThingML configuration

This will also lead to one single Kevoree component, but the ports that are connected within the ThingML configuration will be exposed as Kevoree ports. It is then up to you to properly bind them using the Kevoree editor (or KevScript). This approach is a bit more flexible as it allows you to choose and dynamically change the communication semantics (channels) between your ports. 

> Note that if a ThingML port can both send and receive messages, it will be split into two Kevoree ports, which either send or receive messages. We might re-align the ThingML and Kevoree semantics by leveraging the Kevoree callbacks in a later release of the wrapper.

#### All components are defined in their own ThingML configurations

In this case, we will generate one Kevoree component per ThingML configuration. It is then up to you to load these individual components into the Kevoree editor (or Kevscript) and connect them. This approach is the most flexible. You can change the communication semantics, and you are now able to manage components individually at runtime (e.g. stop the client or replace it by another component).

#### In general

In general, you will most likely use a combination of those three mappings.
